/**
 * Foundation Installer v3.0 - Instala√ß√£o Padronizada
 * 
 * Este m√≥dulo implementa a Fase 3 da arquitetura:
 * - Templates √∫nicos p√≥s-padroniza√ß√£o
 * - Verifica√ß√£o funcional completa
 * - Rollback autom√°tico em falhas
 * 
 * BASEADO NOS PROBLEMAS IDENTIFICADOS:
 * 1. Rotas criadas mas n√£o registradas
 * 2. Verifica√ß√£o p√≥s-instala√ß√£o insuficiente
 * 3. Falsos positivos mascarando problemas
 */

const fs = require('fs');
const path = require('path');
const { scanProject } = require('./foundation-scanner.cjs');

class FoundationInstaller {
  constructor() {
    this.projectRoot = process.cwd();
    this.foundationDir = path.join(this.projectRoot, 'foundation');
    this.backupDir = path.join(this.foundationDir, '.installation-backup');
    this.results = {
      filesCreated: [],
      filesModified: [],
      validationResults: {},
      rollbackNeeded: false,
      success: false,
      errors: []
    };
  }

  /**
   * INSTALADOR PRINCIPAL
   */
  async installFoundation() {
    console.log('üöÄ Foundation Installer v3.0 - Instala√ß√£o Padronizada');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

    try {
      // Pr√©-valida√ß√£o obrigat√≥ria
      console.log('üîç Executando pr√©-valida√ß√£o...');
      const preCheck = await this.preInstallationValidation();
      if (!preCheck.passed) {
        console.log('‚ùå Pr√©-valida√ß√£o falhou. Instala√ß√£o cancelada.');
        return this.results;
      }

      // Criar backup completo
      await this.createInstallationBackup();

      // Instala√ß√£o sequencial
      await this.createFoundationStructure();
      await this.installFoundationRoutes();
      await this.integrateWithServer();
      await this.createFoundationFiles();
      await this.integrateProjectInterface();
      await this.updateManifest();

      // Valida√ß√£o funcional completa
      console.log('\nüß™ Executando valida√ß√£o funcional...');
      const validation = await this.functionalValidation();
      
      if (validation.success) {
        this.results.success = true;
        await this.markInstallationComplete();
        console.log('‚úÖ Foundation instalado com sucesso!');
      } else {
        console.log('‚ùå Valida√ß√£o funcional falhou. Iniciando rollback...');
        await this.performRollback();
      }

    } catch (error) {
      this.addError(`Erro durante instala√ß√£o: ${error.message}`);
      console.log('‚ùå Erro cr√≠tico. Iniciando rollback...');
      await this.performRollback();
    }

    return this.results;
  }

  /**
   * PR√â-VALIDA√á√ÉO OBRIGAT√ìRIA
   */
  async preInstallationValidation() {
    const results = { passed: false, issues: [] };

    // Verificar se Foundation j√° est√° instalado
    if (fs.existsSync(path.join(this.projectRoot, '.foundation-installed'))) {
      results.issues.push('Foundation j√° est√° instalado. Use foundation-remove primeiro.');
      return results;
    }

    // Executar scan completo
    const scanResults = await scanProject();
    
    if (scanResults.classification === 'INCOMPAT√çVEL') {
      results.issues.push('Projeto incompat√≠vel. Execute foundation-migrator primeiro.');
      return results;
    }

    if (scanResults.classification === 'PRECISA_AJUSTES') {
      results.issues.push('Projeto precisa de ajustes. Execute foundation-migrator primeiro.');
      return results;
    }

    // Verificar depend√™ncias cr√≠ticas
    if (!this.checkCriticalDependencies()) {
      results.issues.push('Depend√™ncias cr√≠ticas faltando (express, typescript).');
      return results;
    }

    results.passed = true;
    console.log('‚úÖ Pr√©-valida√ß√£o passou');
    return results;
  }

  /**
   * VERIFICAR DEPEND√äNCIAS CR√çTICAS
   */
  checkCriticalDependencies() {
    const packagePath = path.join(this.projectRoot, 'package.json');
    if (!fs.existsSync(packagePath)) return false;

    try {
      const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
      const allDeps = {
        ...packageData.dependencies || {},
        ...packageData.devDependencies || {}
      };

      const required = ['express', 'typescript'];
      return required.every(dep => allDeps[dep]);
    } catch {
      return false;
    }
  }

  /**
   * CRIAR BACKUP DE INSTALA√á√ÉO
   */
  async createInstallationBackup() {
    try {
      if (!fs.existsSync(this.foundationDir)) {
        fs.mkdirSync(this.foundationDir, { recursive: true });
      }

      if (!fs.existsSync(this.backupDir)) {
        fs.mkdirSync(this.backupDir, { recursive: true });
      }

      const filesToBackup = [
        'server/routes.ts',
        'server/routes.js',
        'server/index.ts',
        'server/index.js'
      ];

      for (const file of filesToBackup) {
        const sourcePath = path.join(this.projectRoot, file);
        if (fs.existsSync(sourcePath)) {
          const backupPath = path.join(this.backupDir, file.replace('/', '_'));
          fs.copyFileSync(sourcePath, backupPath);
        }
      }

      console.log('üíæ Backup de instala√ß√£o criado');
    } catch (error) {
      throw new Error(`Falha ao criar backup: ${error.message}`);
    }
  }

  /**
   * CRIAR ESTRUTURA FOUNDATION
   */
  async createFoundationStructure() {
    const dirs = [
      'foundation',
      'foundation/.config',
      'foundation/monitoring',
      'foundation/templates',
      'server/routes'
    ];

    for (const dir of dirs) {
      const dirPath = path.join(this.projectRoot, dir);
      if (!fs.existsSync(dirPath)) {
        fs.mkdirSync(dirPath, { recursive: true });
        this.results.filesCreated.push(dir);
      }
    }

    console.log('üìÅ Estrutura Foundation criada');
  }

  /**
   * INSTALAR ROTAS FOUNDATION
   */
  async installFoundationRoutes() {
    const routePath = path.join(this.projectRoot, 'server/routes/foundation-setup.js');
    
    // Detectar tipo de m√≥dulo para gerar template correto
    const moduleType = this.detectModuleType();
    const routeTemplate = this.generateFoundationRouteTemplate(moduleType);
    
    fs.writeFileSync(routePath, routeTemplate);
    this.results.filesCreated.push('server/routes/foundation-setup.js');
    
    console.log('üõ†Ô∏è Rota Foundation instalada');
  }

  /**
   * DETECTAR TIPO DE M√ìDULO
   */
  detectModuleType() {
    const packagePath = path.join(this.projectRoot, 'package.json');
    if (fs.existsSync(packagePath)) {
      try {
        const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
        return packageData.type === 'module' ? 'ES_MODULES' : 'COMMONJS';
      } catch {
        return 'COMMONJS';
      }
    }
    return 'COMMONJS';
  }

  /**
   * INTEGRAR COM SERVIDOR
   */
  async integrateWithServer() {
    const routesPath = path.join(this.projectRoot, 'server/routes.ts');
    const routesJSPath = path.join(this.projectRoot, 'server/routes.js');
    
    const targetFile = fs.existsSync(routesPath) ? routesPath : routesJSPath;
    
    if (!fs.existsSync(targetFile)) {
      throw new Error('Arquivo server/routes n√£o encontrado');
    }

    let content = fs.readFileSync(targetFile, 'utf8');
    
    // Adicionar import se n√£o existir
    if (!content.includes('foundation-setup')) {
      const importLine = this.detectModuleType() === 'ES_MODULES' 
        ? "import foundationSetup from './routes/foundation-setup.js';"
        : "const foundationSetup = require('./routes/foundation-setup.js');";
      
      content = importLine + '\n' + content;
      this.results.filesModified.push('Adicionado import foundation-setup');
    }

    // Adicionar registro da rota se n√£o existir
    if (!content.includes('app.use(foundationSetup)')) {
      // Encontrar local para inserir app.use
      const createServerIndex = content.indexOf('createServer(app)');
      if (createServerIndex !== -1) {
        const insertPosition = content.lastIndexOf('\n', createServerIndex);
        const beforeServer = content.substring(0, insertPosition);
        const afterServer = content.substring(insertPosition);
        
        content = beforeServer + '\n  // Foundation routes\n  app.use(foundationSetup);\n' + afterServer;
        this.results.filesModified.push('Registrada rota Foundation no servidor');
      }
    }

    fs.writeFileSync(targetFile, content);
    console.log('üîó Integra√ß√£o com servidor conclu√≠da');
  }

  /**
   * CRIAR ARQUIVOS FOUNDATION
   */
  async createFoundationFiles() {
    // Configura√ß√£o Foundation
    const configPath = path.join(this.foundationDir, '.config/foundation.json');
    const config = {
      version: '3.0.0',
      capacity: 'SMALL',
      installed: new Date().toISOString(),
      features: ['monitoring', 'setup', 'management']
    };
    
    fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
    this.results.filesCreated.push('foundation/.config/foundation.json');

    // README Foundation
    const readmePath = path.join(this.foundationDir, 'README.md');
    const readmeContent = this.generateFoundationReadme();
    fs.writeFileSync(readmePath, readmeContent);
    this.results.filesCreated.push('foundation/README.md');

    console.log('üìÑ Arquivos Foundation criados');
  }

  /**
   * INTEGRAR INTERFACE DO PROJETO (MODIFICA√á√ÉO M√çNIMA)
   */
  async integrateProjectInterface() {
    console.log('üîó Integrando interface do projeto...');
    
    try {
      const FoundationIntegratorSimple = require('./foundation-integrator-simple.cjs');
      const integrator = new FoundationIntegratorSimple();
      
      // Executar integra√ß√£o autom√°tica
      await integrator.integrate();
      
      this.results.filesModified.push('client/src/App.tsx (detec√ß√£o Foundation)');
      console.log('‚úÖ Interface do projeto integrada automaticamente');
      
    } catch (error) {
      console.log('‚ö†Ô∏è Aviso: Integra√ß√£o de interface falhou:', error.message);
      console.log('üí° Execute manualmente: node foundation/foundation-integrator-simple.cjs');
      this.results.warnings = this.results.warnings || [];
      this.results.warnings.push('Integra√ß√£o autom√°tica da interface falhou');
    }
  }

  /**
   * ATUALIZAR MANIFESTO
   */
  async updateManifest() {
    const manifestPath = path.join(this.projectRoot, '.foundation-manifest.json');
    const manifest = {
      version: '3.0.0',
      installed: new Date().toISOString(),
      files: this.results.filesCreated,
      modifications: this.results.filesModified,
      backup: this.backupDir,
      warnings: this.results.warnings || []
    };

    fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2));
    console.log('üìã Manifesto atualizado');
  }

  /**
   * VALIDA√á√ÉO FUNCIONAL
   */
  async functionalValidation() {
    const validation = { success: false, tests: {} };

    try {
      // Teste 1: Verificar se arquivos foram criados
      validation.tests.filesCreated = this.validateFilesCreated();
      
      // Teste 2: Verificar sintaxe dos arquivos
      validation.tests.syntaxValid = this.validateSyntax();
      
      // Teste 3: Verificar integra√ß√£o de rotas
      validation.tests.routeIntegration = this.validateRouteIntegration();
      
      // Aguardar servidor estabilizar
      console.log('‚è≥ Aguardando servidor estabilizar...');
      await this.waitForServer();
      
      // Teste 4: Verificar rota HTTP
      validation.tests.httpRoutes = await this.validateHTTPRoutes();

      // Determinar sucesso geral
      validation.success = Object.values(validation.tests).every(test => test.passed);
      
      this.results.validationResults = validation;
      return validation;

    } catch (error) {
      validation.tests.error = { passed: false, message: error.message };
      this.results.validationResults = validation;
      return validation;
    }
  }

  /**
   * VALIDAR ARQUIVOS CRIADOS
   */
  validateFilesCreated() {
    const requiredFiles = [
      'server/routes/foundation-setup.js',
      'foundation/.config/foundation.json',
      'foundation/README.md'
    ];

    for (const file of requiredFiles) {
      if (!fs.existsSync(path.join(this.projectRoot, file))) {
        return { passed: false, message: `Arquivo ${file} n√£o foi criado` };
      }
    }

    return { passed: true, message: 'Todos os arquivos foram criados' };
  }

  /**
   * VALIDAR SINTAXE
   */
  validateSyntax() {
    try {
      const routePath = path.join(this.projectRoot, 'server/routes/foundation-setup.js');
      const content = fs.readFileSync(routePath, 'utf8');
      
      // Verifica√ß√µes b√°sicas de sintaxe
      if (this.detectModuleType() === 'ES_MODULES') {
        if (!content.includes('import ') || !content.includes('export default')) {
          return { passed: false, message: 'Sintaxe ES modules incorreta' };
        }
      }

      return { passed: true, message: 'Sintaxe v√°lida' };
    } catch (error) {
      return { passed: false, message: `Erro de sintaxe: ${error.message}` };
    }
  }

  /**
   * VALIDAR INTEGRA√á√ÉO DE ROTAS
   */
  validateRouteIntegration() {
    const routesPath = path.join(this.projectRoot, 'server/routes.ts');
    const routesJSPath = path.join(this.projectRoot, 'server/routes.js');
    
    const targetFile = fs.existsSync(routesPath) ? routesPath : routesJSPath;
    
    if (!fs.existsSync(targetFile)) {
      return { passed: false, message: 'Arquivo de rotas n√£o encontrado' };
    }

    const content = fs.readFileSync(targetFile, 'utf8');
    
    if (!content.includes('foundation-setup')) {
      return { passed: false, message: 'Import foundation-setup n√£o encontrado' };
    }

    if (!content.includes('app.use(foundationSetup)')) {
      return { passed: false, message: 'Registro da rota Foundation n√£o encontrado' };
    }

    return { passed: true, message: 'Integra√ß√£o de rotas v√°lida' };
  }

  /**
   * AGUARDAR SERVIDOR
   */
  async waitForServer(timeout = 10000) {
    return new Promise(resolve => setTimeout(resolve, 3000));
  }

  /**
   * VALIDAR ROTAS HTTP
   */
  async validateHTTPRoutes() {
    try {
      const { execSync } = require('child_process');
      
      // Testar rota Foundation
      const foundationTest = execSync('curl -s -o /dev/null -w "%{http_code}" http://localhost:5000/foundation/setup', 
        { timeout: 5000, encoding: 'utf8' });
      
      if (foundationTest.trim() !== '200') {
        return { passed: false, message: `Rota Foundation retornou ${foundationTest}` };
      }

      return { passed: true, message: 'Rotas HTTP funcionando' };
    } catch (error) {
      return { passed: false, message: `Erro ao testar HTTP: ${error.message}` };
    }
  }

  /**
   * MARCAR INSTALA√á√ÉO COMPLETA
   */
  async markInstallationComplete() {
    const markerPath = path.join(this.projectRoot, '.foundation-installed');
    const marker = {
      version: '3.0.0',
      installed: new Date().toISOString(),
      validated: true
    };

    fs.writeFileSync(markerPath, JSON.stringify(marker, null, 2));
    console.log('‚úÖ Instala√ß√£o marcada como completa');
  }

  /**
   * REALIZAR ROLLBACK
   */
  async performRollback() {
    console.log('üîÑ Iniciando rollback...');
    this.results.rollbackNeeded = true;

    try {
      // Remover arquivos criados
      for (const file of this.results.filesCreated) {
        const filePath = path.join(this.projectRoot, file);
        if (fs.existsSync(filePath)) {
          if (fs.statSync(filePath).isDirectory()) {
            fs.rmSync(filePath, { recursive: true, force: true });
          } else {
            fs.unlinkSync(filePath);
          }
        }
      }

      // Restaurar arquivos modificados do backup
      if (fs.existsSync(this.backupDir)) {
        const backupFiles = fs.readdirSync(this.backupDir);
        for (const backupFile of backupFiles) {
          const originalFile = backupFile.replace('_', '/');
          const backupPath = path.join(this.backupDir, backupFile);
          const originalPath = path.join(this.projectRoot, originalFile);
          
          if (fs.existsSync(originalPath)) {
            fs.copyFileSync(backupPath, originalPath);
          }
        }
      }

      console.log('‚úÖ Rollback conclu√≠do');
    } catch (error) {
      console.log(`‚ùå Erro durante rollback: ${error.message}`);
    }
  }

  /**
   * TEMPLATES
   */
  generateFoundationRouteTemplate(moduleType) {
    if (moduleType === 'ES_MODULES') {
      return `// Foundation Setup Route - Auto-gerado (ES Modules)
import express from 'express';
const router = express.Router();

// Rota principal do Foundation Setup
router.get('/foundation/setup', (req, res) => {
  const html = \`
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Foundation Setup v3.0</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
    .container { max-width: 800px; margin: 0 auto; background: white; padding: 40px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
    h1 { color: #2563eb; margin: 0 0 20px 0; }
    .status { background: #dcfce7; color: #166534; padding: 15px; border-radius: 8px; margin: 20px 0; }
    .feature { background: #f8fafc; padding: 15px; border-left: 4px solid #3b82f6; margin: 10px 0; }
    .command { background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: monospace; margin: 10px 0; }
    .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üåü DuEuler Foundation v3.0</h1>
    
    <div class="status">
      ‚úÖ Foundation instalado e funcionando perfeitamente!
    </div>

    <div class="feature">
      <h3>üöÄ Sistema de Padroniza√ß√£o Progressiva</h3>
      <p>Foundation v3.0 implementa arquitetura h√≠brida que combina padroniza√ß√£o r√≠gida para projetos novos com migra√ß√£o assistida para projetos existentes.</p>
    </div>

    <div class="feature">
      <h3>üîç Verifica√ß√£o Preventiva Obrigat√≥ria</h3>
      <p>Sistema bloqueia instala√ß√µes incompat√≠veis automaticamente, detectando problemas antes que ocorram.</p>
    </div>

    <div class="feature">
      <h3>üõ†Ô∏è Templates Din√¢micos</h3>
      <p>Gera√ß√£o autom√°tica de c√≥digo ES modules ou CommonJS baseado no projeto alvo.</p>
    </div>

    <h3>üéØ Comandos Dispon√≠veis:</h3>
    <div class="command">foundation-scanner</div>
    <div class="command">foundation-migrator</div>
    <div class="command">foundation-installer</div>
    <div class="command">foundation-remove</div>

    <div class="footer">
      <p><strong>DuEuler Foundation v3.0</strong> - Sistema empresarial de desenvolvimento</p>
      <p>Instalado em: \${new Date().toLocaleString('pt-BR')}</p>
    </div>
  </div>
</body>
</html>
  \`;
  
  res.send(html);
});

export default router;
`;
    } else {
      return `// Foundation Setup Route - Auto-gerado (CommonJS)
const express = require('express');
const router = express.Router();

// Rota principal do Foundation Setup
router.get('/foundation/setup', (req, res) => {
  const html = \`
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Foundation Setup v3.0</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
    .container { max-width: 800px; margin: 0 auto; background: white; padding: 40px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); }
    h1 { color: #2563eb; margin: 0 0 20px 0; }
    .status { background: #dcfce7; color: #166534; padding: 15px; border-radius: 8px; margin: 20px 0; }
    .feature { background: #f8fafc; padding: 15px; border-left: 4px solid #3b82f6; margin: 10px 0; }
    .command { background: #1e293b; color: #e2e8f0; padding: 15px; border-radius: 8px; font-family: monospace; margin: 10px 0; }
    .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #e5e7eb; color: #6b7280; }
  </style>
</head>
<body>
  <div class="container">
    <h1>üåü DuEuler Foundation v3.0</h1>
    
    <div class="status">
      ‚úÖ Foundation instalado e funcionando perfeitamente!
    </div>

    <div class="feature">
      <h3>üöÄ Sistema de Padroniza√ß√£o Progressiva</h3>
      <p>Foundation v3.0 implementa arquitetura h√≠brida que combina padroniza√ß√£o r√≠gida para projetos novos com migra√ß√£o assistida para projetos existentes.</p>
    </div>

    <div class="footer">
      <p><strong>DuEuler Foundation v3.0</strong> - Sistema empresarial de desenvolvimento</p>
      <p>Instalado em: \${new Date().toLocaleString('pt-BR')}</p>
    </div>
  </div>
</body>
</html>
  \`;
  
  res.send(html);
});

module.exports = router;
`;
    }
  }

  generateFoundationReadme() {
    return `# Foundation v3.0 - Sistema Instalado

## üéâ Instala√ß√£o Conclu√≠da

O Foundation v3.0 foi instalado com sucesso em seu projeto utilizando a arquitetura de **Padroniza√ß√£o Progressiva H√≠brida**.

## üåü Recursos Instalados

### ‚úÖ Sistema de Verifica√ß√£o Preventiva
- Detec√ß√£o autom√°tica de incompatibilidades
- Bloqueio de instala√ß√µes problem√°ticas
- Valida√ß√£o funcional completa

### ‚úÖ Templates Din√¢micos
- Gera√ß√£o autom√°tica ES modules/CommonJS
- Adapta√ß√£o ao tipo de projeto
- Sintaxe sempre correta

### ‚úÖ Integra√ß√£o Validada
- Rotas registradas no servidor
- Testes HTTP funcionais
- Rollback autom√°tico em falhas

## üöÄ Acesso ao Sistema

**Interface Web:** http://localhost:5000/foundation/setup

## üõ†Ô∏è Comandos Dispon√≠veis

- \`foundation-scanner\` - An√°lise completa do projeto
- \`foundation-migrator\` - Migra√ß√£o autom√°tica
- \`foundation-remove\` - Desinstala√ß√£o completa

## üìã Arquivos Instalados

- \`server/routes/foundation-setup.js\` - Rota principal
- \`foundation/.config/foundation.json\` - Configura√ß√£o
- \`.foundation-installed\` - Marcador de instala√ß√£o
- \`.foundation-manifest.json\` - Manifesto detalhado

## üîß Suporte

Para problemas ou d√∫vidas, consulte:
- \`foundation/TROUBLESHOOTING.md\`
- \`foundation/FOUNDATION-ARCHITECTURE.md\`

---

**Instalado em:** ${new Date().toLocaleString('pt-BR')}  
**Vers√£o:** 3.0.0  
**Status:** ‚úÖ Validado e Funcional
`;
  }

  /**
   * UTILIT√ÅRIOS
   */
  addError(error) {
    this.results.errors.push(error);
    console.log(`‚ùå ${error}`);
  }

  /**
   * GERAR RELAT√ìRIO
   */
  generateReport() {
    console.log('\nüìä RELAT√ìRIO DE INSTALA√á√ÉO');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');

    console.log(`\nüéØ Status: ${this.results.success ? 'SUCESSO' : 'FALHA'}`);

    if (this.results.filesCreated.length > 0) {
      console.log('\nüìÅ ARQUIVOS CRIADOS:');
      this.results.filesCreated.forEach(file => {
        console.log(`   ‚úÖ ${file}`);
      });
    }

    if (this.results.filesModified.length > 0) {
      console.log('\nüîß MODIFICA√á√ïES:');
      this.results.filesModified.forEach(mod => {
        console.log(`   ‚úÖ ${mod}`);
      });
    }

    if (this.results.validationResults.tests) {
      console.log('\nüß™ TESTES DE VALIDA√á√ÉO:');
      Object.entries(this.results.validationResults.tests).forEach(([test, result]) => {
        const icon = result.passed ? '‚úÖ' : '‚ùå';
        console.log(`   ${icon} ${test}: ${result.message}`);
      });
    }

    if (this.results.errors.length > 0) {
      console.log('\n‚ùå ERROS:');
      this.results.errors.forEach(error => {
        console.log(`   ‚Ä¢ ${error}`);
      });
    }

    if (this.results.rollbackNeeded) {
      console.log('\nüîÑ Rollback executado devido a falhas na valida√ß√£o');
    }

    if (this.results.success) {
      console.log('\nüåê Acesse: http://localhost:5000/foundation/setup');
      console.log('üõ†Ô∏è Para desinstalar: foundation-remove');
    }

    return this.results;
  }
}

/**
 * FUN√á√ÉO PRINCIPAL EXPORTADA
 */
async function installFoundation() {
  const installer = new FoundationInstaller();
  const results = await installer.installFoundation();
  installer.generateReport();
  
  // Salvar relat√≥rio de instala√ß√£o
  const reportPath = path.join(installer.foundationDir, 'installation-report.json');
  if (!fs.existsSync(installer.foundationDir)) {
    fs.mkdirSync(installer.foundationDir, { recursive: true });
  }
  fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
  
  console.log(`\nüíæ Relat√≥rio salvo em: ${reportPath}`);
  
  return results;
}

// Executar se chamado diretamente
if (require.main === module) {
  installFoundation().catch(console.error);
}

module.exports = { FoundationInstaller, installFoundation };